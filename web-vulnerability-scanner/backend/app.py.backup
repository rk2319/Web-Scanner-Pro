from flask import Flask, request, jsonify, Response
from flask_cors import CORS
import requests
import socket
import threading
import queue
import json
import time
import logging
from datetime import datetime
import urllib.parse
import ssl
import re
import ipaddress
from concurrent.futures import ThreadPoolExecutor
from bs4 import BeautifulSoup
import dns.resolver
from security_checks import SecurityChecker 

# Initialize Flask app
app = Flask(__name__)
CORS(app)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('security_scanner.log')
    ]
)
logger = logging.getLogger(__name__)

# Global queue for logs
log_queue = queue.Queue()

def add_log(message, type="info"):
    """Add a log message to the queue with timestamp"""
    log_entry = {
        "timestamp": datetime.now().isoformat(),
        "message": message,
        "type": type
    }
    log_queue.put(log_entry)
    logger.info(f"{type.upper()}: {message}")

def generate_log_stream():
    """Generate SSE stream for logs with keepalive"""
    while True:
        try:
            log_entry = log_queue.get(timeout=1)
            yield f"data: {json.dumps(log_entry)}\n\n"
        except queue.Empty:
            # Send keepalive every second
            yield f"data: {json.dumps({'type': 'keepalive'})}\n\n"
        except Exception as e:
            logger.error(f"Error in log stream: {str(e)}")
            yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"

class PortScanner:
    def __init__(self):
        self.common_ports = {
            20: 'FTP-DATA',
            21: 'FTP',
            22: 'SSH',
            23: 'TELNET',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            111: 'RPC',
            135: 'MSRPC',
            139: 'NetBIOS',
            143: 'IMAP',
            443: 'HTTPS',
            445: 'SMB',
            993: 'IMAPS',
            995: 'POP3S',
            1433: 'MSSQL',
            1521: 'Oracle',
            3306: 'MySQL',
            3389: 'RDP',
            5432: 'PostgreSQL',
            5900: 'VNC',
            6379: 'Redis',
            8080: 'HTTP-Proxy',
            8443: 'HTTPS-Alt',
            27017: 'MongoDB'
        }
        self.dangerous_ports = {21, 23, 445, 3389, 5900}
        self.timeout = 1

    def scan_port(self, target, port):
        """Scan a single port"""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(self.timeout)
                result = sock.connect_ex((target, port))
                if result == 0:
                    service_info = self.detect_service(sock, port)
                    service_info['port'] = port
                    service_info['state'] = 'open'
                    risk_info = self.assess_port_risk(port, service_info)
                    service_info.update(risk_info)
                    return service_info
                return None
        except Exception as e:
            logger.debug(f"Error scanning port {port}: {str(e)}")
            return None

    def detect_service(self, sock, port):
        """Detect service running on port"""
        service_info = {
            'service': self.common_ports.get(port, 'unknown'),
            'version': 'unknown',
            'product': 'unknown'
        }
        
        try:
            if port in [80, 443, 8080, 8443]:
                sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
            elif port == 22:
                pass  # SSH servers send banner automatically
            else:
                sock.send(b"\r\n")
                
            banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
            service_info['banner'] = banner
            
            # Try to detect version from banner
            if banner:
                version_match = re.search(r'(\d+\.[\d.]+)', banner)
                if version_match:
                    service_info['version'] = version_match.group(1)
                    
                # Try to detect product
                if 'apache' in banner.lower():
                    service_info['product'] = 'Apache'
                elif 'nginx' in banner.lower():
                    service_info['product'] = 'Nginx'
                elif 'microsoft' in banner.lower():
                    service_info['product'] = 'Microsoft'
                    
        except Exception as e:
            logger.debug(f"Error detecting service: {str(e)}")
            service_info['banner'] = 'No banner available'
            
        return service_info

    def assess_port_risk(self, port, service_info):
        """Assess risk level of open port"""
        risk_info = {
            'risk_level': 'Low',
            'risk_description': [],
            'recommendations': []
        }

        # Check for dangerous ports
        if port in self.dangerous_ports:
            risk_info['risk_level'] = 'High'
            risk_info['risk_description'].append(
                f"Port {port} ({service_info['service']}) should not be exposed"
            )
            risk_info['recommendations'].append(f"Close port {port} or restrict access")

        # Check for non-standard ports
        if service_info['service'] == 'HTTP' and port not in [80, 8080]:
            risk_info['risk_description'].append("Non-standard HTTP port in use")
            risk_info['recommendations'].append("Consider using standard port 80 for HTTP")

        if service_info['service'] == 'HTTPS' and port not in [443, 8443]:
            risk_info['risk_description'].append("Non-standard HTTPS port in use")
            risk_info['recommendations'].append("Consider using standard port 443 for HTTPS")

        # Check for old versions
        if service_info.get('version') and service_info['version'] != 'unknown':
            if any(old in service_info['version'].lower() for old in ['1.0', '2.0', '3.0']):
                risk_info['risk_level'] = 'High'
                risk_info['risk_description'].append(
                    f"Potentially outdated version: {service_info['version']}"
                )
                risk_info['recommendations'].append("Update service to latest version")

        return risk_info

    def scan_target(self, target, ports=None):
        """Scan target for open ports"""
        if ports is None:
            ports = self.common_ports.keys()
            
        add_log(f"Starting port scan for {target}", "info")
        results = []
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_port = {
                executor.submit(self.scan_port, target, port): port 
                for port in ports
            }
            
            for future in future_to_port:
                try:
                    result = future.result()
                    if result:
                        results.append(result)
                        add_log(
                            f"Found open port {result['port']} "
                            f"({result['service']}) - {result['risk_level']} risk",
                            "warning" if result['risk_level'] in ['High', 'Critical'] else "info"
                        )
                except Exception as e:
                    logger.error(f"Error scanning port: {str(e)}")
                    
        add_log(f"Port scan completed. Found {len(results)} open ports", "success")
        return results

class SecurityScanner:
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
        }
        self.timeout = 10

    def scan_website(self, url):
        """Main scanning function with progress updates"""
        try:
            add_log("Initializing security scan", "info")
            
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url

            hostname = self.clean_hostname(url)
            add_log(f"Starting security scan for {url}", "info")

            results = {
                'url': url,
                'scan_time': datetime.now().isoformat(),
                'hostname': hostname,
                'vulnerabilities': [],
                'security_headers': [],
                'summary': {
                    'total_issues': 0,
                    'critical': 0,
                    'high': 0,
                    'medium': 0,
                    'low': 0
                }
            }

            # SSL/TLS Check
            add_log("Checking SSL/TLS configuration", "info")
            if url.startswith('https://'):
                ssl_result = self.check_ssl_certificate(hostname)
                if ssl_result:
                    results['vulnerabilities'].append(ssl_result)
            else:
                results['vulnerabilities'].append({
                    'type': 'Protocol Security',
                    'description': 'Website not using HTTPS',
                    'severity': 'High'
                })

            # Security Headers Check
            add_log("Analyzing security headers", "info")
            try:
                response = requests.get(url, headers=self.headers, timeout=self.timeout, verify=True)
                header_results = self.check_security_headers(response.headers)
                results['security_headers'] = header_results
                if header_results.get('issues'):
                    results['vulnerabilities'].extend(header_results['issues'])
            except requests.exceptions.RequestException as e:
                add_log(f"Failed to check security headers: {str(e)}", "error")

            # Vulnerability Scanning
            add_log("Starting comprehensive vulnerability scan", "info")
            security_checker = SecurityChecker()
            security_results = security_checker.perform_comprehensive_scan(url)
            results['security_checks'] = security_results

            # Update summary
            self.update_summary(results)
            
            # Calculate risk score
            risk_score = self.calculate_risk_score(results)
            results['risk_assessment'] = {
                'score': risk_score,
                'level': self.get_risk_level(risk_score),
                'last_scan': datetime.now().isoformat()
            }

            add_log("Scan completed successfully", "success")
            return results

        except Exception as e:
            add_log(f"Scan failed: {str(e)}", "error")
            raise

    def clean_hostname(self, url):
        """Extract clean hostname from URL"""
        try:
            parsed = urllib.parse.urlparse(url)
            return parsed.netloc if parsed.netloc else parsed.path.split('/')[0]
        except Exception as e:
            logger.error(f"Error cleaning hostname: {str(e)}")
            return url

    def check_security_headers(self, headers):
        """Check for security headers"""
        security_headers = {
            'Strict-Transport-Security': {
                'description': 'HSTS',
                'severity': 'High',
                'recommendation': 'Implement HTTP Strict Transport Security'
            },
            'Content-Security-Policy': {
                'description': 'CSP',
                'severity': 'High',
                'recommendation': 'Implement Content Security Policy'
            },
            'X-Frame-Options': {
                'description': 'X-Frame-Options',
                'severity': 'Medium',
                'recommendation': 'Set X-Frame-Options to prevent clickjacking'
            },
            'X-Content-Type-Options': {
                'description': 'X-Content-Type-Options',
                'severity': 'Medium',
                'recommendation': 'Set X-Content-Type-Options to nosniff'
            },
            'Referrer-Policy': {
                'description': 'Referrer-Policy',
                'severity': 'Medium',
                'recommendation': 'Set appropriate Referrer-Policy'
            }
        }

        results = {
            'present': [],
            'missing': [],
            'issues': []
        }

        for header, info in security_headers.items():
            if header not in headers:
                results['missing'].append({
                    'header': header,
                    'description': info['description']
                })
                results['issues'].append({
                    'type': 'Security Header',
                    'description': f'Missing {info["description"]} header',
                    'severity': info['severity'],
                    'recommendation': info['recommendation']
                })
            else:
                results['present'].append({
                    'header': header,
                    'value': headers[header]
                })

        return results

    def check_ssl_certificate(self, hostname):
        """Check SSL certificate"""
        try:
            add_log("Checking SSL certificate", "info")
            context = ssl.create_default_context()
            with socket.create_connection((hostname, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_until_expiry = (not_after - datetime.now()).days
                    
                    if days_until_expiry < 0:
                        return {
                            'type': 'SSL Certificate',
                            'description': 'SSL Certificate has expired',
                            'severity': 'Critical'
                        }
                    elif days_until_expiry < 30:
                        return {
                            'type': 'SSL Certificate',
                            'description': f'SSL Certificate expiring soon ({days_until_expiry} days)',
                            'severity': 'High'
                        }
            return None
        except Exception as e:
            add_log(f"SSL certificate check failed: {str(e)}", "error")
            return {
                'type': 'SSL Certificate',
                'description': f'SSL verification failed: {str(e)}',
                'severity': 'High'
            }

    def update_summary(self, results):
        """Update vulnerability summary"""
        for vuln in results['vulnerabilities']:
            severity = vuln['severity'].lower()
            if severity in results['summary']:
                results['summary'][severity] += 1
            results['summary']['total_issues'] += 1

    def calculate_risk_score(self, results):
        """Calculate risk score"""
        weights = {
            'Critical': 10,
            'High': 7,
            'Medium': 4,
            'Low': 1
        }

        total_weight = 0
        max_weight = 0

        for vuln in results['vulnerabilities']:
            severity = vuln['severity']
            weight = weights.get(severity, 1)
            total_weight += weight
            max_weight += 10

        # Include security checks in risk score
        if 'security_checks' in results:
            sec_checks = results['security_checks']
            total_weight += (
                sec_checks['overall_risk']['critical_vulnerabilities'] * 10 +
                sec_checks['overall_risk']['high_vulnerabilities'] * 7 +
                sec_checks['overall_risk']['medium_vulnerabilities'] * 4 +
                sec_checks['overall_risk']['low_vulnerabilities'] * 1
            )
            max_weight += sec_checks['overall_risk']['total_checks'] * 10

        return round((total_weight / max_weight * 100) if max_weight > 0 else 0, 1)

    def get_risk_level(self, score):
        """Determine risk level based on score"""
        if score >= 80:
            return 'Critical'
        elif score >= 60:
            return 'High'
        elif score >= 40:
            return 'Medium'
        else:
            return 'Low'

# Flask routes
@app.route('/scan', methods=['POST'])
def start_scan():
    try:
        data = request.get_json()
        if not data or 'url' not in data:
            return jsonify({'error': 'URL is required'}), 400

        url = data['url']
        scanner = SecurityScanner()  # Your existing scanner
        security_checker = SecurityChecker()  # New security checker
        
        try:
            # Perform both scans
            basic_results = scanner.scan_website(url)
            security_results = security_checker.perform_comprehensive_scan(url)
            
            # Merge results
            combined_results = {
                **basic_results,
                'security_checks': security_results,
                'scan_time': datetime.now().isoformat()
            }
            
            return jsonify(combined_results)
        except ValueError as ve:
            return jsonify({'error': str(ve)}), 400
        except Exception as e:
            logger.error(f"Scan failed: {str(e)}")
            return jsonify({'error': 'Scan failed. Please check the URL and try again.'}), 500

    except Exception as e:
        logger.error(f"Request processing failed: {str(e)}")
        return jsonify({'error': 'Invalid request'}), 400

@app.route('/scan', methods=['POST'])
def start_scan():
    """Handle scan requests"""
    try:
        data = request.get_json()
        if not data or 'url' not in data:
            return jsonify({'error': 'URL is required'}), 400

        url = data['url']
        scanner = SecurityScanner()
        
        try:
            add_log(f"Starting new scan for {url}", "info")
            results = scanner.scan_website(url)
            return jsonify(results)
        except ValueError as ve:
            add_log(f"Scan failed with validation error: {str(ve)}", "error")
            return jsonify({'error': str(ve)}), 400
        except Exception as e:
            add_log(f"Scan failed with error: {str(e)}", "error")
            return jsonify({'error': 'Scan failed. Please check the URL and try again.'}), 500

    except Exception as e:
        logger.error(f"Request processing failed: {str(e)}")
        return jsonify({'error': 'Invalid request'}), 400

@app.route('/logs')
def logs():
    """SSE endpoint for live logs"""
    return Response(
        generate_log_stream(),
        mimetype='text/event-stream',
        headers={
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
            'Access-Control-Allow-Origin': '*'
        }
    )

if __name__ == '__main__':
    logger.info("Starting Security Scanner Server...")
    app.run(debug=True, host='0.0.0.0', port=8000, threaded=True)