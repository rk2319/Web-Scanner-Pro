from flask import Flask, request, jsonify, Response
from flask_cors import CORS
import requests
import socket
import threading
import queue
import json
import time
import logging
from datetime import datetime
import urllib.parse
import ssl
import re
import ipaddress
from concurrent.futures import ThreadPoolExecutor
from bs4 import BeautifulSoup
import dns.resolver
import traceback
import whois
import OpenSSL
from cryptography import x509
from cryptography.hazmat.backends import default_backend
import idna
import urllib3
import concurrent.futures

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('scanner.log')
    ]
)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
CORS(app, resources={r"/*": {"origins": "*"}})

# Global queue for logs
log_queue = queue.Queue()

def add_log(message, type="info"):
    """Add a log message to the queue"""
    log_entry = {
        "timestamp": datetime.now().isoformat(),
        "message": message,
        "type": type
    }
    log_queue.put(log_entry)
    logger.info(f"{type.upper()}: {message}")

class ScanProgress:
    def __init__(self):
        self.phases = {
            'initialization': {'weight': 5, 'status': 'pending', 'progress': 0},
            'ssl_check': {'weight': 20, 'status': 'pending', 'progress': 0},
            'dns_check': {'weight': 15, 'status': 'pending', 'progress': 0},
            'port_scan': {'weight': 20, 'status': 'pending', 'progress': 0},
            'headers_check': {'weight': 15, 'status': 'pending', 'progress': 0},
            'whois_check': {'weight': 10, 'status': 'pending', 'progress': 0},
            'vulnerability_analysis': {'weight': 15, 'status': 'pending', 'progress': 0}
        }
        self.overall_progress = 0

    def update_phase(self, phase, progress, status='in_progress'):
        if phase in self.phases:
            self.phases[phase]['progress'] = progress
            self.phases[phase]['status'] = status
            self.calculate_overall_progress()

    def calculate_overall_progress(self):
        total_weight = sum(phase['weight'] for phase in self.phases.values())
        weighted_progress = sum(
            (phase['weight'] * phase['progress'] / 100)
            for phase in self.phases.values()
        )
        self.overall_progress = round((weighted_progress / total_weight) * 100, 1)

    def get_status(self):
        return {
            'overall_progress': self.overall_progress,
            'phases': self.phases
        }
class SecurityScanner:
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (compatible; SecurityScanner/1.0)'
        }
        self.timeout = 10
        self.common_ports = {
            80: 'HTTP',
            443: 'HTTPS',
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            3306: 'MySQL',
            8080: 'HTTP-Proxy',
            8443: 'HTTPS-Alt',
            3389: 'RDP',
            5432: 'PostgreSQL'
        }
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    def clean_hostname(self, url):
        """Extract clean hostname from URL"""
        try:
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            parsed = urllib.parse.urlparse(url)
            return parsed.netloc if parsed.netloc else parsed.path.split('/')[0]
        except Exception as e:
            logger.error(f"Error cleaning hostname: {str(e)}")
            return url

    def check_ssl_certificate(self, hostname):
        """Enhanced SSL certificate checker with better error handling"""
        try:
            add_log(f"Starting SSL check for {hostname}", "info")
            
            # Convert internationalized domain names to ASCII
            hostname_idna = idna.encode(hostname).decode('ascii')
            
            cert_info = {
                'valid': False,
                'issuer': None,
                'subject': None,
                'version': None,
                'serial_number': None,
                'not_before': None,
                'not_after': None,
                'issues': []
            }

            try:
                # Create SSL context with modern security settings
                context = ssl.create_default_context()
                context.check_hostname = True
                context.verify_mode = ssl.CERT_REQUIRED

                with socket.create_connection((hostname_idna, 443), timeout=self.timeout) as sock:
                    add_log(f"Established connection to {hostname}", "info")
                    
                    with context.wrap_socket(sock, server_hostname=hostname_idna) as ssock:
                        cert_data = ssock.getpeercert()
                        
                        # Extract certificate details
                        cert_info.update({
                            'valid': True,
                            'issuer': dict(x[0] for x in cert_data['issuer']),
                            'subject': dict(x[0] for x in cert_data['subject']),
                            'version': cert_data['version'],
                            'serial_number': cert_data['serialNumber'],
                            'not_before': cert_data['notBefore'],
                            'not_after': cert_data['notAfter']
                        })

                        # Check certificate expiration
                        not_after = datetime.strptime(cert_data['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        not_before = datetime.strptime(cert_data['notBefore'], '%b %d %H:%M:%S %Y %Z')
                        days_until_expiry = (not_after - datetime.now()).days
                        
                        if days_until_expiry < 0:
                            cert_info['issues'].append({
                                'type': 'SSL Certificate Expired',
                                'description': 'The SSL certificate has expired',
                                'severity': 'Critical',
                                'recommendation': 'Renew the SSL certificate immediately'
                            })
                        elif days_until_expiry < 30:
                            cert_info['issues'].append({
                                'type': 'SSL Certificate Expiring Soon',
                                'description': f'Certificate expires in {days_until_expiry} days',
                                'severity': 'High',
                                'recommendation': 'Plan to renew the SSL certificate'
                            })

                        # Additional certificate checks
                        self._check_certificate_strength(ssock, cert_info)
                        
                        add_log("SSL certificate check completed successfully", "success")

            except ssl.SSLCertVerificationError as e:
                cert_info['issues'].append({
                    'type': 'SSL Certificate Verification Failed',
                    'description': str(e),
                    'severity': 'Critical',
                    'recommendation': 'Ensure the certificate is valid and trusted'
                })
                add_log(f"SSL certificate verification failed: {str(e)}", "error")

            except ssl.SSLError as e:
                cert_info['issues'].append({
                    'type': 'SSL Protocol Error',
                    'description': str(e),
                    'severity': 'Critical',
                    'recommendation': 'Check SSL configuration and supported protocols'
                })
                add_log(f"SSL protocol error: {str(e)}", "error")

            except socket.timeout:
                cert_info['issues'].append({
                    'type': 'Connection Timeout',
                    'description': 'Connection timed out while checking SSL certificate',
                    'severity': 'Medium',
                    'recommendation': 'Check network connectivity and server response time'
                })
                add_log("SSL check timed out", "error")

            except socket.gaierror as e:
                cert_info['issues'].append({
                    'type': 'DNS Resolution Error',
                    'description': f'Could not resolve hostname: {str(e)}',
                    'severity': 'High',
                    'recommendation': 'Verify the domain name is correct'
                })
                add_log(f"DNS resolution error: {str(e)}", "error")

            return cert_info

        except Exception as e:
            add_log(f"Unexpected error in SSL check: {str(e)}", "error")
            return {
                'valid': False,
                'issues': [{
                    'type': 'SSL Check Failed',
                    'description': f'Failed to check SSL certificate: {str(e)}',
                    'severity': 'High',
                    'recommendation': 'Manual investigation required'
                }]
            }

    def _check_certificate_strength(self, ssl_socket, cert_info):
        """Check SSL/TLS configuration strength"""
        try:
            # Get cipher being used
            cipher = ssl_socket.cipher()
            if cipher:
                protocol_version = ssl_socket.version()
                
                # Check protocol version
                if protocol_version == "TLSv1" or protocol_version == "TLSv1.1":
                    cert_info['issues'].append({
                        'type': 'Weak Protocol Version',
                        'description': f'Using outdated protocol: {protocol_version}',
                        'severity': 'High',
                        'recommendation': 'Upgrade to TLS 1.2 or higher'
                    })

                # Check cipher strength
                cipher_name = cipher[0]
                if "NULL" in cipher_name or "RC4" in cipher_name or "MD5" in cipher_name:
                    cert_info['issues'].append({
                        'type': 'Weak Cipher Suite',
                        'description': f'Using weak cipher: {cipher_name}',
                        'severity': 'High',
                        'recommendation': 'Configure server to use strong cipher suites only'
                    })

        except Exception as e:
            add_log(f"Error checking certificate strength: {str(e)}", "error")
            cert_info['issues'].append({
                'type': 'Certificate Strength Check Failed',
                'description': str(e),
                'severity': 'Medium',
                'recommendation': 'Manual investigation of SSL configuration recommended'
            })

    def scan_ports(self, target):
        """Scan common ports"""
        results = []
        add_log(f"Starting port scan for {target}", "info")
        
        def check_port(port):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                    sock.settimeout(1)
                    result = sock.connect_ex((target, port))
                    if result == 0:
                        service = self.common_ports.get(port, 'Unknown')
                        risk_level = 'High' if port in [21, 23, 3389] else 'Medium'
                        add_log(f"Found open port {port} ({service})", "warning")
                        return {
                            'port': port,
                            'service': service,
                            'state': 'open',
                            'risk_level': risk_level
                        }
            except Exception as e:
                logger.error(f"Error scanning port {port}: {str(e)}")
            return None

        with ThreadPoolExecutor(max_workers=10) as executor:
            port_results = list(executor.map(check_port, self.common_ports.keys()))
            results = [r for r in port_results if r is not None]

        return results

    def check_dns(self, hostname):
        """Check DNS records"""
        dns_info = {
            'a_records': [],
            'mx_records': [],
            'txt_records': [],
            'ns_records': [],
            'issues': []
        }

        try:
            resolver = dns.resolver.Resolver()
            
            # A records
            try:
                a_records = resolver.resolve(hostname, 'A')
                dns_info['a_records'] = [str(r) for r in a_records]
            except Exception as e:
                dns_info['issues'].append(f"No A records found: {str(e)}")

            # MX records
            try:
                mx_records = resolver.resolve(hostname, 'MX')
                dns_info['mx_records'] = [str(r.exchange) for r in mx_records]
            except Exception as e:
                dns_info['issues'].append("No MX records found")

            # TXT records
            try:
                txt_records = resolver.resolve(hostname, 'TXT')
                dns_info['txt_records'] = [str(r) for r in txt_records]
                
                # Check for SPF and DMARC
                has_spf = any('v=spf1' in str(r) for r in txt_records)
                has_dmarc = any('v=DMARC1' in str(r) for r in txt_records)
                
                if not has_spf:
                    dns_info['issues'].append({
                        'type': 'Missing SPF Record',
                        'description': 'No SPF record found',
                        'severity': 'Medium',
                        'recommendation': 'Implement SPF record to prevent email spoofing'
                    })
                if not has_dmarc:
                    dns_info['issues'].append({
                        'type': 'Missing DMARC Record',
                        'description': 'No DMARC record found',
                        'severity': 'Medium',
                        'recommendation': 'Implement DMARC record for better email security'
                    })
            except Exception as e:
                dns_info['issues'].append("No TXT records found")

        except Exception as e:
            dns_info['issues'].append(f"DNS check failed: {str(e)}")

        return dns_info

    def check_security_headers(self, headers):
        """Check security headers"""
        security_headers = {
            'Strict-Transport-Security': {
                'description': 'HSTS',
                'severity': 'High',
                'recommendation': 'Implement HTTP Strict Transport Security'
            },
            'Content-Security-Policy': {
                'description': 'CSP',
                'severity': 'High',
                'recommendation': 'Implement Content Security Policy'
            },
            'X-Frame-Options': {
                'description': 'X-Frame-Options',
                'severity': 'Medium',
                'recommendation': 'Set X-Frame-Options to prevent clickjacking'
            },
            'X-Content-Type-Options': {
                'description': 'X-Content-Type-Options',
                'severity': 'Medium',
                'recommendation': 'Set X-Content-Type-Options to nosniff'
            },
            'X-XSS-Protection': {
                'description': 'XSS Protection',
                'severity': 'Medium',
                'recommendation': 'Enable XSS Protection'
            },
            'Referrer-Policy': {
                'description': 'Referrer Policy',
                'severity': 'Medium',
                'recommendation': 'Set appropriate Referrer Policy'
            }
        }

        results = {
            'present': [],
            'missing': [],
            'issues': []
        }

        for header, info in security_headers.items():
            if header not in headers:
                results['missing'].append({
                    'header': header,
                    'description': info['description']
                })
                results['issues'].append({
                    'type': 'Missing Security Header',
                    'description': f'Missing {info["description"]} header',
                    'severity': info['severity'],
                    'recommendation': info['recommendation']
                })
            else:
                results['present'].append({
                    'header': header,
                    'value': headers[header]
                })

        return results

    def check_whois(self, hostname):
        """Check WHOIS information"""
        try:
            w = whois.whois(hostname)
            return {
                'registrar': w.registrar,
                'creation_date': str(w.creation_date) if w.creation_date else None,
                'expiration_date': str(w.expiration_date) if w.expiration_date else None,
                'last_updated': str(w.updated_date) if w.updated_date else None,
                'status': w.status,
                'name_servers': w.name_servers
            }
        except Exception as e:
            logger.error(f"WHOIS check failed: {str(e)}")
            return None

    def update_summary(self, results):
        """Update vulnerability summary"""
        for vuln in results['vulnerabilities']:
            severity = vuln['severity'].lower()
            if severity in results['summary']:
                results['summary'][severity] += 1
            results['summary']['total_issues'] += 1

    def calculate_risk_score(self, results):
        """Calculate risk score"""
        weights = {
            'Critical': 10,
            'High': 7,
            'Medium': 4,
            'Low': 1
        }
        total_weight = 0
        max_possible_weight = 0

        for vuln in results['vulnerabilities']:
            severity = vuln['severity']
            weight = weights.get(severity, 1)
            total_weight += weight
            max_possible_weight += 10

        # Include port scan results in risk score
        for port in results['port_scan']:
            if port['state'] == 'open':
                if port['risk_level'] == 'High':
                    total_weight += weights['High']
                else:
                    total_weight += weights['Medium']
                max_possible_weight += 10

        # Check DNS issues
        if results['dns_info'] and results['dns_info'].get('issues'):
            if isinstance(results['dns_info']['issues'], list):
                dns_issues = [issue for issue in results['dns_info']['issues'] 
                            if isinstance(issue, dict) and 'severity' in issue]
                total_weight += sum(weights.get(issue['severity'], 1) for issue in dns_issues)
                max_possible_weight += len(dns_issues) * 10

        return round((total_weight / max_possible_weight * 100) if max_possible_weight > 0 else 0, 1)

    def get_risk_level(self, score):
        """Determine risk level based on score"""
        if score >= 80:
            return 'Critical'
        elif score >= 60:
            return 'High'
        elif score >= 40:
            return 'Medium'
        else:
            return 'Low'

    def scan_website(self, url):
        """Main scanning function with improved parallel processing"""
        try:
            add_log("Initializing security scan", "info")
            
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url

            hostname = self.clean_hostname(url)
            add_log(f"Starting security scan for {url}", "info")

            results = {
                'url': url,
                'scan_time': datetime.now().isoformat(),
                'hostname': hostname,
                'vulnerabilities': [],
                'security_headers': None,
                'port_scan': [],
                'dns_info': None,
                'whois_info': None,
                'ssl_info': None,
                'content_scan': {'issues': []},
                'summary': {
                    'total_issues': 0,
                    'critical': 0,
                    'high': 0,
                    'medium': 0,
                    'low': 0
                }
            }

            try:
                # Parallel execution of independent scans
                with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
                    # Start all scans concurrently
                    future_ssl = executor.submit(self.check_ssl_certificate, hostname)
                    future_dns = executor.submit(self.check_dns, hostname)
                    future_whois = executor.submit(self.check_whois, hostname)
                    future_ports = executor.submit(self.scan_ports, hostname)

                    # Wait for all results
                    results['ssl_info'] = future_ssl.result()
                    add_log("SSL certificate check completed", "success")

                    results['dns_info'] = future_dns.result()
                    add_log("DNS check completed", "success")

                    results['whois_info'] = future_whois.result()
                    add_log("WHOIS check completed", "success")

                    results['port_scan'] = future_ports.result()
                    add_log("Port scan completed", "success")

                # Sequential checks that depend on HTTP response
                try:
                    response = requests.get(
                        url, 
                        headers=self.headers, 
                        timeout=self.timeout,
                        verify=True
                    )
                    results['security_headers'] = self.check_security_headers(response.headers)
                    add_log("Security headers check completed", "success")

                except requests.exceptions.SSLError as e:
                    add_log(f"SSL Error during HTTP request: {str(e)}", "error")
                    results['vulnerabilities'].append({
                        'type': 'SSL Connection Error',
                        'description': str(e),
                        'severity': 'High',
                        'recommendation': 'Verify SSL certificate configuration'
                    })

                except requests.exceptions.RequestException as e:
                    add_log(f"HTTP request failed: {str(e)}", "error")
                    results['vulnerabilities'].append({
                        'type': 'Connection Error',
                        'description': str(e),
                        'severity': 'Medium',
                        'recommendation': 'Check server connectivity and configuration'
                    })

                # Consolidate vulnerabilities
                if results['ssl_info'] and results['ssl_info'].get('issues'):
                    results['vulnerabilities'].extend(results['ssl_info']['issues'])
                
                if results['security_headers'] and results['security_headers'].get('issues'):
                    results['vulnerabilities'].extend(results['security_headers']['issues'])

                if results['dns_info'] and results['dns_info'].get('issues'):
                    dns_issues = [issue for issue in results['dns_info']['issues'] 
                                if isinstance(issue, dict) and 'type' in issue]
                    results['vulnerabilities'].extend(dns_issues)

                # Update summary statistics
                self.update_summary(results)

                # Calculate final risk assessment
                risk_score = self.calculate_risk_score(results)
                results['risk_assessment'] = {
                    'score': risk_score,
                    'level': self.get_risk_level(risk_score),
                    'last_scan': datetime.now().isoformat()
                }

                add_log("Scan completed successfully", "success")
                return results

            except Exception as e:
                add_log(f"Error during scan: {str(e)}", "error")
                logger.error(traceback.format_exc())
                raise

        except Exception as e:
            add_log(f"Scan failed: {str(e)}", "error")
            logger.error(traceback.format_exc())
            raise

def generate_log_stream():
    """Generate SSE stream for logs"""
    while True:
        try:
            log_entry = log_queue.get(timeout=1)
            yield f"data: {json.dumps(log_entry)}\n\n"
        except queue.Empty:
            yield f"data: {json.dumps({'type': 'keepalive'})}\n\n"
        except Exception as e:
            logger.error(f"Error in log stream: {str(e)}")
            yield f"data: {json.dumps({'type': 'error', 'message': str(e)})}\n\n"

@app.route('/scan', methods=['POST'])
def start_scan():
    """Endpoint to start a security scan"""
    try:
        data = request.get_json()
        if not data or 'url' not in data:
            return jsonify({'error': 'URL is required'}), 400

        url = data['url']
        scanner = SecurityScanner()
        
        try:
            add_log(f"Starting new scan for {url}", "info")
            results = scanner.scan_website(url)
            return jsonify(results)
        except ValueError as ve:
            add_log(f"Scan failed with validation error: {str(ve)}", "error")
            return jsonify({'error': str(ve)}), 400
        except Exception as e:
            add_log(f"Scan failed with error: {str(e)}", "error")
            logger.error(traceback.format_exc())
            return jsonify({'error': 'Scan failed. Please check the URL and try again.'}), 500

    except Exception as e:
        logger.error(f"Request processing failed: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({'error': 'Invalid request'}), 400

@app.route('/logs')
def logs():
    """SSE endpoint for live logs"""
    return Response(
        generate_log_stream(),
        mimetype='text/event-stream',
        headers={
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
            'Access-Control-Allow-Origin': '*'
        }
    )

@app.route('/health')
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'version': '1.0.0',
        'scan_queue_size': log_queue.qsize()
    })

if __name__ == '__main__':
    try:
        logger.info("Starting Security Scanner Server...")
        logger.info("Initializing with the following features:")
        logger.info("- Port Scanning")
        logger.info("- SSL/TLS Analysis")
        logger.info("- Security Headers Check")
        logger.info("- DNS Configuration Analysis")
        logger.info("- WHOIS Information")
        logger.info("- Live Logging")
        logger.info("Server is ready to accept requests")
        app.run(debug=True, host='0.0.0.0', port=8000, threaded=True)
    except Exception as e:
        logger.error(f"Server failed to start: {str(e)}")
        logger.error(traceback.format_exc())